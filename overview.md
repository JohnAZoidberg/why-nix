- What is Nix?
  - What does it do with your system?
    - On installation
    - During runtime
- Features of Nix
  - Builds packages but doesn't replace traditional build tools (e.g. make)
  - Source based (but with binary cache)
  - Always having the newest packages (if not - update yourself)
  - Atomic installation, upgrades and rollback
    - Installations cannot fail
    - Installations don't clutter your system
    - Uninstalling is not having the package on your $PATH
    - `nix-collect-garbage` if running low on space
  - Lazy evaluation
  - Purely functional - only dependend on inputs
  - Overriding system packages with overlay
- What can you use Nix for?
  - Temporary shell
    - Packages and environment variables
    - Shell with language packages
    - Shell with everything necessary to build package
  - Building ISO
  - Building packages
    - Regular packages (Gentoo style)
    - Cross compiling
    - While developing
  - Modifying packages
    - Supplying a patch
    - Changing source entirely
    - Changing configure, installPhase or anything else
  - Absolute transparency on how something is built
  - Portability -  the only thing you need is Nix
  - Absolute reproducibility with pinning nixpkgs
- Why is Nix special?
  - On any Linux or MacOS system!
  - Easily have multiple versions of a package
  - Immutable package store
  - Isolated build environment
- Problem that Nix eliminates
  - No lock on package database! You can run multiple builds or installations
  - No "conflict between packages [go solve it yourself]"
  - No root required
  - Installing packages doesn't pollute the system
- Problems with Nix
  - Little documentation
  - Code is the documentation (code is mostly easy to read)
  - Not the biggest community
  - Custom dynamic linker interpreter (ld-linux.so) hardcoded
- NixOS?
  - `service.enable = true`
